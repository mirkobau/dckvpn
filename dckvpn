#!/bin/bash

# Name: dckvpn
# Author: Mirko Graziani (mirkobau)
# GitHub repo: https://github.com/mirkobau/dckvpn
# Release: 20210610, with a glass of beer in my hand.
# Language: bash scripting
# Intended use: technical users (FIXME: make a YT video for making this available to everyone)
# Requires: bash, docker-ce, screen, openssl, GNU coreutils.
#
# Description:
# builds a docker image based on 'fedora' and uses it as a
# selective gateway to a variety of concurrently open VPN Clients.
#
# Note for Windows 8/10 (and beyond?)
# Windows 10's network routing strategy is a great system..for domesticated monkeys.
# So if you're such that evolved animal that you
# expect to get what you typed in your routing table..
# ..then you'll need to cope a couple of minutes with gpedit.msc.
# So, after opening it:
#
# 1. Go to: Computer Configuration\Administrative Templates\Network\Windows Connection Manager
# 2. Set 'Minimize Number of Simultaneous Connections to Internet or a Windows Domain' to "Enabled" and "0".
# 3. Reboot
# 4. Enjoy it, my little rascal: you're free now.
#
# FIXME: add option to choose from other docker images
# WONTFIX: But hey,
# after a quick search this was the only one I found being able
# to install all required packages without any kind of magic tricks.
# And honestly, if it works and this all is about docker,
# then I don't feel portability as an essential need.

function dbg {
   echo "$@" 1>&2
}
export -f dbg

function todevnull {
   "$@" &> /dev/null
}
export -f todevnull

# ensures required packages are present in the system
function pkgrequirements {
   for REQNAME in "$@" ; do
      export REQNAME
      if [[ -z "$( dnf list installed $REQNAME 2> /dev/null )" ]] ; then
         dnf -y install "$REQNAME"
      fi
   done
}
export -f pkgrequirements

# Takes settings encrypted file,
# decrypts it
# gives to stdout a bunch of commands for 'eval'
# that - hopefully - recreate saved variables and theyr respective values
function loadsettings {
   dbg "Loading settings from file '$VPNSETTINGSFILE'."

   (
      echo "$VPNNAME"
      openssl enc -base64 -d < "$VPNSETTINGSFILE"
   ) \
   | openssl enc -aes-256-cbc -d -pbkdf2 -pass stdin

   # ...(continued from 'savesettings' function)
   # when you'll open this VPN next time, we'll
   # load these settings replacing the former saved ones.
   # The file will be deleted once correctly loaded.
   if [[ -f "$VPNROUTESFILE" && -s "$VPNROUTESFILE" ]] ; then
      dbg "Found new routes file '$VPNROUTESFILE': setting new routes."
      echo "export VPNROUTES='$(cat "$VPNROUTESFILE")'"

      dbg "Removing '$VPNROUTESFILE'."
      rm -f "$VPNROUTESFILE"
   fi
}
export -f loadsettings

function savesettings {
   dbg "Saving settings to file 'VPNSETTINGSFILE'."
   (
      echo "$VPNNAME"
      # 'VPNVARNAMES' variable is populated in the global initialization part (see below)
      for VPNVARNAME in $VPNVARNAMES ; do
         echo "export $VPNVARNAME='${!VPNVARNAME}'"
      done
   ) \
   | openssl enc -aes-256-cbc -base64 -pbkdf2 -pass stdin \
   > "$VPNSETTINGSFILE"

   # if you 'touch "$VPNROUTESFILE"', leaving it empty (zero bytes),
   # that file will be populated next time you'll user the VPN.
   # then...(continued in 'loadsettings' function)
   if [[ -f "$VPNROUTESFILE" && ! -s "$VPNROUTESFILE" ]] ; then
      dbg "Found new routes empty file '$VPNROUTESFILE': populating it."
      echo "$VPNROUTES" > "$VPNROUTESFILE"
   fi
}
export -f savesettings

function todck {
   # Write to docker container without translating any escape sequence.
   for DCKNEXTLINE in "$@" ; do
      echo "$DCKNEXTLINE" >&$todckfd
      sleep 0.4
   done
}
export -f todck

function fmdck {
   export fmdckline=""
   while read -rst $DCKREADTIMEOUT -u $fmdckfd fmdckline && [[ -z "$fmdckline" ]] ; do
      sleep 0.4
   done
   echo "$fmdckline"
}
export -f fmdck

# make the container spit out a random variable (FIXME: $RANDOM isn't really random),
# then send given commands to the container.
# What's next?
# 1. wait for that random variable in a single line by itself,
#    eating out everything was in buffer before it.
# 2. read lines from container and echo them to stdout, until we get an empty line
# 
# FIXME: (improvement) step2 --> read until we read a certain line marker
# WONTFIX: there's no need for a line marker at the end of the output,
# since all functions and loops are built on the line marker at the beginning of output.
function dckchat {
   export DCKLINEMARK="DCKLINEMARK#$RANDOM"
   export DCKNEXTLINE="$DCKLINEMARK"

   # send to container the line marker and subsequent commands given
   todck "echo $DCKNEXTLINE" "$@"

   # Look for line marker
   while [[ "$( fmdck )" != "$DCKLINEMARK" ]] ; do
      true
   done

   # read & echo lines, until we get an empty one
   # (this is intended as "nothing else to read")
   while [[ -n "$DCKNEXTLINE" ]] ; do
      export DCKNEXTLINE="$( fmdck )"
      echo "$DCKNEXTLINE" | egrep -v "^ *\r?*$"
   done
}
export -f dckchat

# This is a little different from other '...dck' functions defined here.
# 
# We here execute a *new* shell inside the container, and pass it the given commands.
# This is useful for inspecting main process behaviour,
# like i.e. charon-cmd in ipsecvpn function, in which
# we dynamically re-engineer routes created by charon-cmd.
function indck {
   for DCKNEXTLINE in "$@" ; do
      echo "$DCKNEXTLINE"
   done \
   | docker container exec -i --privileged "$VPNNAME" su -s /bin/bash
}
export -f indck

function dckid {
   docker ps -q -f "ancestor=dckvpn" -f "name=$VPNNAME"
}
export -f dckid

function killdck {
   dbg "Killing a previously running container with name '$1'."
   todevnull docker kill "$1"
   todevnull docker rm "$1"
}
export -f killdck

function dcktables {
   export DCKTRAFFICSEL="$1"
   shift

   indck \
   "iptables -t nat -I POSTROUTING $DCKTRAFFICSEL -j MASQUERADE" \
   "iptables -t filter -I FORWARD $DCKTRAFFICSEL -m state --state NEW -j ACCEPT"
}
export -f dcktables

# Opens a OpenVPN client
# VPNNAME is (must be) also the name of the folder '/etc/openvpn/$VPNNAME'
# This folder will be copied to docker container, and
# openvpn will be launched with according parameters --cd and --config.
# the $VPNNAME.ovpn config file must contain a line 'dev XXXX',
# where XXXX will be subsequently used as interface name for routes and iptables rules.
function ovpn {
   indck "base64 -d | tar x -vC /etc/openvpn" "$(
      tar c -C /etc/openvpn "$VPNNAME" | base64
   )"

   # extract line with interface name from config file
   export OVPNDEV="$( egrep "^ *dev " /etc/openvpn/$VPNNAME/$VPNNAME.ovpn )"
   # cut off everything except interface name
   export OVPNDEV="${OVPNDEV##* }"

   # MASQUERADE encapsulated traffic, as usual
   # ACCEPT new connections towards "any" on the other side of the tunnel
   dcktables "-o '$OVPNDEV'"

   dbg "Launching openvpn in container."
   export OVPNCMD="openvpn --cd '/etc/openvpn/$VPNNAME' --config '$VPNNAME.ovpn'"
   dckchat "$OVPNCMD 2>&1"
}
export -f ovpn



# Launches a 'openfortivpn' client inside container for SSL VPN connections toward a FortiGate NGFW.
function ofvpn {
   # Reconnect every 16 seconds if VPN drops

   export OFVPNCMD="openfortivpn '$VPNIP' -u '$VPNUSR' -p '$VPNPWD' --persistent=16"

   # openfortivpn can put to stdout the following results:
   #
   # "Using interface..."
   # This means everything is OK for puntting on the tunnel.
   # The final word is interface name.
   #
   # ERROR:      --trusted-cert HexCharsHexCharsHexCharsHexCharsHexCharsHexCharsHexCharsHexChars
   # Tunnel will not be correctly set up, because we need
   # to add a command-line argument for accepting gateway's certificate.
   # openfortivpn will exit, so we'll need to re-spawn a second one.
   # FIXME: add a mechanism to only accept a specific certificate.
   dbg "Launching openfortivpn in container."
   export OFVPNLINE="$( dckchat "$OFVPNCMD 2>&1" )"
   export OFVPNLINE1=""
   while [[ -n "$( indck "pstree | egrep 'openfortivpn'" 2> /dev/null )" && -z "$OFVPNLINE1" ]] ; do
      # show openfortivpn output to user
      echo "$OFVPNLINE"

      # Intercept a specific line in openfortivpn's response.
      export OFVPNLINE1="$( egrep -m1 "(Using interface|--trusted-cert)" <<< "$OFVPNLINE" )"

      # Keep only last word: is contains the value we were looking for.
      export OFVPNLINEDATAVALUE="${OFVPNLINE1##* }"

      # On the other side, cut apart the part before the value
      export OFVPNLINEDATANAME="${OFVPNLINE1% $OFVPNLINEDATAVALUE}"
      # Cut off everything until the last space.
      # This wil lbring us to a 'interface' or a '--trusted-cert' value in variable
      export OFVPNLINEDATANAME="${OFVPNLINEDATANAME##* }"

      # Do something if we found a useful line.
      if [[ -z "$OFVPNLINE1" ]] ; then
         # We still got nothing useful from container.

         # Get next line from container
         export OFVPNLINE="$( fmdck )"
      else
         case "$OFVPNLINEDATANAME" in
         interface)
            # The VPN tunnel will be created!
            # Let's configure the firewall.
            dcktables "-o '$OFVPNLINEDATAVALUE'"
         ;;
         --trusted-cert)
            dbg "openfortivpn complained about an untrusted certificate."
            # Add parameters to command line
            export OFVPNCMD="$OFVPNCMD $OFVPNLINEDATANAME $OFVPNLINEDATAVALUE"

            # Enqueue a fresh new openfortivpn command inside docker container,
            # and get first lines that it puts on stdout.
            dbg "Launching openfortivpn in container again,"
            dbg "this time with --trusted-cert option correctly set."
            export OFVPNLINE="$( dckchat "$OFVPNCMD 2>&1" )"
         ;;
         esac
      fi
   done
}
export -f ofvpn



# Interface function to 'openconnect'.
# All necessary parameters are pre-set in exported environment variables.
function ocvpn {
   # Arbitrary interface name
   export OCVPNDEV=tun8
   # this is gonna be used only once: in the next line,
   # but I keep it here for clearness.
   export OCVPNCMD="openconnect -i '$OCVPNDEV' '--protocol=$VPNTYPE' -u '$VPNUSR' --passwd-on-stdin '$VPNIP'"

   dbg "Launching openconnect in container."
   export OCVPNLINE="$( dckchat "$OCVPNCMD 2>&1" "$VPNPWD" )"

   dbg "Waiting 4 seconds (arbitrary) for openconnect to esatblish the connection with gateway."
   sleep 4

   while [[ -n "$OCVPNLINE" ]] ; do
      echo "$OCVPNLINE"

      # This comes just before "Enter 'yes' to accept, 'no' to abort" line.
      # Line that will not be read until someone enters something, so the stdout will spit out a newline.
      # This is why we look for the "line before" instead of the effective one.
      export OCVPNLINETEST="$( egrep -m1 -- "--servercert " <<< "$OCVPNLINE" )"
      if [[ -n "$OCVPNLINETEST" ]] ; then
         todck "yes"
      elif [[ "$OCVPNLINETEST" == "BBB" ]] ; then
         # This is here for future uses.
         true
      fi

      # Sleep a while (this will avoid stdout flood)
      sleep 0.4
      # Get next line from docker
      export OCVPNLINE="$( fmdck )"
   done

   # Set up firewall
   dcktables "-o '$OCVPNDEV'"
}
export -f ocvpn



# Guess IPSEC VPNs interface function.
# We use charon-cmd from strongSwan here.
function ipsecvpn {
   # These values are taken from: https://wiki.strongswan.org/projects/strongswan/wiki/IKEv1CipherSuites
   export DHGROUPS="
      s/DH1/modp768/g
      s/DH2/modp1024/g
      s/DH5/modp1536/g
      s/DH14/modp2048/g
      s/DH15/modp3072/g
      s/DH16/modp4096/g
      s/DH17/modp6144/g
      s/DH18/modp8192/g
      s/DH22/modp1024s160/g
      s/DH23/modp2048s224/g
      s/DH24/modp2048s256/g
      s/DH25/ecp192/g
      s/DH26/ecp224/g
      s/DH19/ecp256/g
      s/DH20/ecp384/g
      s/DH21/ecp521/g
      s/DH27/ecp224bp/g
      s/DH28/ecp256bp/g
      s/DH29/ecp384bp/g
      s/DH30/ecp512bp/g
      s/DH31/curve25519/g
      s/DH31/x25519/g
   "

   # Change 'DHxx' into correspondent parameter for charon-cmd..
   # ..for so-called 'Phase 1'..
   export VPNPHASE1EDIT="$( sed -re "$DHGROUPS" <<< "$VPNPHASE1" )"
   # ..and for so-called 'Phase 2'.
   export VPNPHASE2EDIT="$( sed -re "$DHGROUPS" <<< "$VPNPHASE2" )"

   # Convert phase1 and phase2 cipher suites definitions to lowercase
   export VPNPHASE1EDIT="${VPNPHASE1EDIT,,}"
   export VPNPHASE2EDIT="${VPNPHASE2EDIT,,}"

   # The default ip route table 220 created by charon-cmd is a "catchall" route.
   # Here we'll need a more fine-grained routes, so we put this away and create new route rules later.
   # Here below we're only making sure there's no pre-existing ip route table 220 before we begin to work.
   dbg "Flushing ip route table 220."
   indck "ip route flush table 220"

   dbg "Launching charon-cmd in container."
   todck \
   "charon-cmd \\
   --host '$VPNIP' \\
   --remote-identity %any \\
   --identity '$VPNID' \\
   --xauth-username '$VPNUSR' \\
   --profile ikev1-xauth-psk-am \\
   --ike-proposal '$VPNPHASE1EDIT' \\
   --esp-proposal '$VPNPHASE2EDIT' \\
   --debug -1"

   dbg "Waiting 2 seconds (arbitrary), then sending username to charon-cmd."
   sleep 2
   todck "$VPNPSK"

   dbg "Waiting 1 seconds (arbitrary), then sending password to charon-cmd."
   sleep 1
   todck "$VPNPWD"

   dbg "Waiting for charon-cmd to create ip route table 220."
   export VPNCLITABLE=""
   while [[ -z "$VPNCLITABLE" ]] ; do
      sleep 1
      export VPNCLITABLE="$( indck "ip route list table 220 exact default" )"
   done

   dbg "Extracting informations from ip route table 220."

   export VPNCLIDEV="${VPNCLITABLE##* dev }"
   export VPNCLIDEV="${VPNCLIDEV%% *}"

   export VPNCLIIP="${VPNCLITABLE##* src }"
   export VPNCLIIP="${VPNCLIIP%% *}"

   dbg "Flushing ip route table 220 and creating fine-grained routes."

   indck "ip route flush table 220"
   for VPNROUTE in $VPNROUTES ; do
      # while remaining a best practice, this adds an
      # uncomfortable '-j MASQUERADE' rule to POSTROUTING chain in nat table.
      # We don't care too much about this,
      # because the -j SNAT (see below) will take precedence
      dcktables "-d '$VPNROUTE'"

      indck \
      "ip route add '$VPNROUTE' dev $VPNCLIDEV via '$VPNCLIIP' table 220" \
      "iptables -t nat -I POSTROUTING -d '$VPNROUTE' -j SNAT --to-source '$VPNCLIIP'"
   done
}
export -f ipsecvpn

function cleanroutes {
   dbg "Cleaning host's routes."
   # Clean host's old routes.
   for VPNROUTE in $VPNROUTES ; do
      todevnull ip route delete "$VPNROUTE" dev docker0
   done

   dbg "Flushing iptables inside container."
   todck "iptables -F &> /dev/null"
}
export -f cleanroutes

function setroutes {
   # Clean all predefined routes if already defined.
   cleanroutes

   dbg "Setting iptables inside container."
   # FIXED: create better iptables rules, based on the actual
   # interface and/or IP addresses used in docker container.
   # FIXED in functions:
   # ovpn: DONE
   # ofvpn: DONE
   # ocvpn: DONE
   # ipsecvpn: DONE
   # Build basic iptables rules
   todck \
   "iptables -t filter -I FORWARD -j REJECT" \
   "iptables -t filter -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT"

   dbg "Setting host's routes."
   # set host's new routes to the container
   for VPNROUTE in $VPNROUTES ; do
      todevnull ip route add $VPNROUTE dev docker0 via $DCKIP 
   done
}
export -f setroutes




dbg "Checking requirements."
# Well, Forrest, you'll require..
pkgrequirements \
   bash \
   docker-ce \
   screen \
   openssl \
   # ..that- that's about it

# VPN Name is a key value:
# - it's used to compose the settings file name,
# - it's used as a (weak) encryption key for settings file
#   About this: I *KNOW* this has nothing to do with security in any way,
#   but at the same time this is a base from which to start for an improvement.
#   (see comments to VPNENCPWD variable)
export VPNNAME="$1"
shift

export VPNNAME="${VPNNAME%.dckvpn}"

case "$VPNNAME" in
ls|list|ps)
   docker ps -f "ancestor=dckvpn"

   exit
;;
kill)
   export VPNNAME="$1"
   shift

   killdck "$VPNNAME"

   exit
;;
esac

while [[ -z "$VPNNAME" ]] ; do
   echo -n "VPN Name:"
   read -r VPNNAME
done

# We'd like to run in a screen.
if [[ -z "${STY##.$VPNNAME}" ]] ; then
   dbg "Spawning a screen session."
   screen -S "$VPNNAME" "$0" "$VPNNAME" "$@"
   dbg "Execution continued on screen session.   Bye."
   exit
fi

dbg "Verifying base image."
# Verify the base image is ready; if not, prepare it.
if [[ -z "$(docker image ls dckvpn -q 2> /dev/null)" ]] ; then
   dbg "Base image not ready."

   dbg "Pulling Fedora."
   # Pull base image.
   # Fedora has been found to be suitable for our needs.
   docker image pull fedora

   dbg "Installing packages inside container."
   dbg "(this may take a while and will seem unresponsive but..just have faith)"
   # we need some packages to make everything run OK
   docker container run --name dckvpn -i --privileged fedora su <<< '
      dnf -y install iproute iptables iputils nftables tcpdump
      dnf -y install openfortivpn openconnect vpnc openvpn strongswan
      dnf -y install openssh
      dnf -y upgrade
   '

   dbg "Committing to base image 'dckvpn'."
   # FIXME: check if packages were correctly installed
   #echo -m 256M --cpus 1
   # This will be our image with which we'll work.
   docker commit dckvpn dckvpn

   dbg "Removing temporary container used for image generation."
   # The container is no longer useful.
   docker container rm dckvpn

   dbg "Trying to spit out a welcome message inside a docker container."
   # Spit out a message about the end of preparation.
   docker container run --name dckvpn -it --privileged --rm dckvpn bash -c "echo Image dckvpn is ready."

   dbg "Image preparation ended.   Hopefully without incidents.   -____-"
fi

# FIXME: verify host's NIC IP address is a link-local (169.254.0.0/16)
# or whatever other security and/or security-through-obscurity feature
# that gives in some way a pretty good ensurance about host's security.

# This will be the encryption key, read from stdin by openssl.
# FIXME: use a better encryption key.
#        For example, ask the key to the user everytime they launch this script.
#        Or read the key from user's computer through an SSH (cygwin or similar required for Windows environments).
#        The following is just a basic idea to get system BIOS UUID:
#
#           wmic path win32_computersystemproduct get uuid | egrep "^.{8}(-.{4}){4}.{8}"
export VPNENCPWD="$VPNNAME"

# kill an already-running container with same name
killdck "$VPNNAME"

while [[ -z "$( dckid )" ]] ; do
   dbg "(re)spawning a container in a co-process."
   # Spawn a container in a bash coprocess.
   # The container is interactive (meaning stdXXX file descriptors are attached to our session)
   # We run as root inside the container, and we get a standard bash environment by elevating our privileges with 'su'.
   # The shell is interactive, meaning that it will receive our stind ad will give us its stdout.
   coproc dckvpnproc {
      docker container run -i --name "$VPNNAME" --privileged --rm dckvpn su -s /bin/bash 2>&1
   }
   sleep 1
done

export dckvpnproc

# FIXME: container must be running

# cosmetic: take out the coproc stdin and stoud file descriptors
export todckfd=${dckvpnproc[1]}
export fmdckfd=${dckvpnproc[0]}

# Arbitrary: 2 seconds of read timeout
export DCKREADTIMEOUT=0.4

dbg "Getting host IP address as seen from inside docker (it's the same as from host's point-of-view)."
# Take host's IP as seen from inside docker.
# This is (sould be) the same address in host's ip route tables.
export HOSTIP="$( dckchat 'ip route list exact default | cut -d " " -f 3' )"

dbg "Getting container's IP address."
# Take container's IP: this will be used when setting host's routes.
export DCKIP="$( 
   dckchat '
      ip addr list dev eth0 \
      | egrep " inet " \
      | cut -d / -f 1 \
      | cut -d t -f 2 \
      | cut -d " " -f 2
   '
)"

# We'll work on this global variables.
export VPNVARSFM="$(( $LINENO + 1 ))"
export VPNROUTES=""
export VPNTYPE=""
export VPNIP=""
export VPNUSR=""
export VPNPWD=""
export VPNID=""
export VPNPHASE1=""
export VPNPHASE2=""
export VPNPSK=""
export VPNVARSTO="$(( $LINENO - 1 ))"

export VPNVARNAMES="$(
   sed -nre "$VPNVARSFM,$VPNVARSTO{
      s/^[^ ]+ ([^=]+)=.*$/\1/g
      p
   }" "$0"
)"

export VPNSETTINGSFILE="$VPNNAME.dckvpn"
export VPNROUTESFILE="$VPNNAME.routes"
# Take variable's values from saved file, if present
if [[ -f "$VPNSETTINGSFILE" ]] ; then
   eval "$( loadsettings )"
else
   echo -n "  Routes:"
   read -r VPNROUTES

   echo -n "VPN type:"
   read -r VPNTYPE

   echo -n " Peer IP:"
   read -r VPNIP

   echo -n "     Usr:"
   read -r VPNUSR
   echo -n "     Pwd:"
   read -rs VPNPWD
   echo
fi

export VPNTYPE="${VPNTYPE,,}"

# Set routes before starting any kind of VPN client
setroutes


dbg "Choosing VPN Client and launching it."
case "$VPNTYPE" in
ov|ovpn|openvpn)
   export VPNTYPE="openvpn"
   ovpn
;;
gp|anyconnect|ac)
   if [[ "$VPNTYPE" == "ac" ]] ; then
      export VPNTYPE="anyconnect"
   fi
   ocvpn
;;
fortissl|ofvpn|of)
   ofvpn
;;
ipsec)
   if [[ -z "$VPNID" ]] ; then
      dbg "..oops, it's a IPSEC VPN: we need a bit of extra infos."

      echo -n " Peer ID:"
      read -r VPNID
      echo -n "  Phase1:"
      read -r VPNPHASE1
      echo -n "  Phase2:"
      read -r VPNPHASE2
      echo -n "     PSK:"
      read -rs VPNPSK
      echo
   fi

   ipsecvpn
;;
*)
   echo "No vaild options given; switching to 'cat-to-null' mode.   Press ctrl+d to end stdin."
   cat &> /dev/null
   exit
;;
esac

dbg "VPN Client connection phase is over."

dbg "Detaching screen in 3 seconds.   You can re-attach it with: screen -r $VPNNAME."
sleep 3
# Detach user interface: there's no need for holding user's attention.
screen -d "$STY"

savesettings

dbg "Starting VPN Monitor loop."
# While VPN clients are running inside docker, simply wait.
# Otherwise, proceed with cleanup.
while [[ -n "$( indck "pstree | egrep '(openvpn|openconnect|openfortivpn|charon-cmd)'" 2> /dev/null )" ]] ; do
   export DCKLINE="$( fmdck 2> /dev/null )"
   if [[ -n "$DCKLINE" ]] ; then
      echo "$DCKLINE"
   fi
   sleep 0.4
done

killdck "$VPNNAME"

cleanroutes
